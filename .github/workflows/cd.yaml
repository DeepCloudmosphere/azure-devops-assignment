name: CD — build, scan, push, deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write

env:
  K8S_NAMESPACE: default

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: azure-devops-assignment
    outputs:
      image_user: ${{ steps.build_user.outputs.image }}
      image_order: ${{ steps.build_order.outputs.image }}
      image_gateway: ${{ steps.build_gateway.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build & push user-service
        id: build_user
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/user-service:${{ github.sha }}
          docker build -t $IMAGE ./user-service
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Build & push order-service
        id: build_order
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/order-service:${{ github.sha }}
          docker build -t $IMAGE ./order-service
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Build & push gateway
        id: build_gateway
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/gateway:${{ github.sha }}
          docker build -t $IMAGE ./gateway
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

  # scan-images:
  #   needs: build-and-push
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Trivy scan - user
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: ${{ needs.build-and-push.outputs.image_user }}

  #     - name: Trivy scan - order
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: ${{ needs.build-and-push.outputs.image_order }}

  #     - name: Trivy scan - gateway
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: ${{ needs.build-and-push.outputs.image_gateway }}

  deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    environment: azure-devops-assignment
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS credentials (kubectl context)
        uses: azure/aks-set-context@v3
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          cluster-name: ${{ secrets.AKS_NAME }}
          resource-group: ${{ secrets.AKS_RG }}

      - name: Confirm kubectl connectivity
        run: kubectl get nodes -o wide

      - name: Apply k8s manifests (create/update resources)
        run: |
          # Apply whatever manifests you have (creates Deployment the first time)
          kubectl apply -f k8s/ -n "${{ env.K8S_NAMESPACE }}" || kubectl apply -f k8s/

      - name: Wait for new resources to be accepted by API (short)
        run: sleep 5

      - name: Update images (only if built) and wait for rollout
        env:
          IMAGE_USER: ${{ needs.build-and-push.outputs.image_user }}
          IMAGE_ORDER: ${{ needs.build-and-push.outputs.image_order }}
          IMAGE_GATEWAY: ${{ needs.build-and-push.outputs.image_gateway }}
          NAMESPACE: ${{ env.K8S_NAMESPACE }}
        run: |
          set -euo pipefail
          # user-service
          if [ -n "${IMAGE_USER:-}" ]; then
            echo "Setting image for user-service -> ${IMAGE_USER}"
            kubectl -n "$NAMESPACE" set image deployment/user-service user="${IMAGE_USER}" --record || echo "set image returned nonzero"
            kubectl -n "$NAMESPACE" rollout status deployment/user-service --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy user-service && kubectl -n "$NAMESPACE" get pods -l app=user-service -o wide && exit 1)
          else
            echo "IMAGE_USER empty — skipping user-service update"
          fi

          # order-service
          if [ -n "${IMAGE_ORDER:-}" ]; then
            echo "Setting image for order-service -> ${IMAGE_ORDER}"
            kubectl -n "$NAMESPACE" set image deployment/order-service order="${IMAGE_ORDER}" --record || echo "set image returned nonzero"
            kubectl -n "$NAMESPACE" rollout status deployment/order-service --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy order-service && kubectl -n "$NAMESPACE" get pods -l app=order-service -o wide && exit 1)
          else
            echo "IMAGE_ORDER empty — skipping order-service update"
          fi

          # gateway
          if [ -n "${IMAGE_GATEWAY:-}" ]; then
            echo "Setting image for gateway -> ${IMAGE_GATEWAY}"
            kubectl -n "$NAMESPACE" set image deployment/gateway gateway="${IMAGE_GATEWAY}" --record || echo "set image returned nonzero"
            kubectl -n "$NAMESPACE" rollout status deployment/gateway --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy gateway && kubectl -n "$NAMESPACE" get pods -l app=gateway -o wide && exit 1)
          else
            echo "IMAGE_GATEWAY empty — skipping gateway update"
          fi

      - name: Post-deploy smoke test (gateway health)
        run: |
          LB_IP=$(kubectl -n "${{ env.K8S_NAMESPACE }}" get svc gateway -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || true)
          if [ -n "$LB_IP" ]; then
            echo "Gateway LB IP: $LB_IP"
            curl --fail --retry 5 --retry-delay 2 "http://$LB_IP/health"
          else
            echo "No external LB IP — testing from a pod"
            POD=$(kubectl -n "${{ env.K8S_NAMESPACE }}" get pods -l app=gateway -o jsonpath="{.items[0].metadata.name}")
            kubectl -n "${{ env.K8S_NAMESPACE }}" exec "$POD" -- curl --fail --retry 5 --retry-delay 2 http://localhost:3000/health
          fi
      # - name: Update user-service image and wait rollout
      #   run: |
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" set image deployment/user-service user=${{ needs.build-and-push.outputs.image_user }} --record
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" rollout status deployment/user-service --timeout=120s

      # - name: Update order-service image and wait rollout
      #   run: |
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" set image deployment/order-service order=${{ needs.build-and-push.outputs.image_order }} --record
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" rollout status deployment/order-service --timeout=120s

      # - name: Update gateway image and wait rollout
      #   run: |
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" set image deployment/gateway gateway=${{ needs.build-and-push.outputs.image_gateway }} --record
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" rollout status deployment/gateway --timeout=120s

      # - name: Post-deploy smoke test (gateway health)
      #   run: |
      #     # if service is LoadBalancer
      #     LB_IP=$(kubectl -n "${{ env.K8S_NAMESPACE }}" get svc gateway -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || true)
      #     if [ -n "$LB_IP" ]; then
      #       echo "Gateway LB IP: $LB_IP"
      #       curl --fail --retry 5 --retry-delay 2 "http://$LB_IP/health"
      #     else
      #       echo "No external LB IP detected — attempting cluster-internal curl (requires kubectl exec access)"
      #       POD=$(kubectl -n "${{ env.K8S_NAMESPACE }}" get pods -l app=gateway -o jsonpath="{.items[0].metadata.name}")
      #       kubectl -n "${{ env.K8S_NAMESPACE }}" exec "$POD" -- curl --fail --retry 5 --retry-delay 2 http://localhost:3000/health
      #     fi
