name: CD — build, scan, push, deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write

env:
  K8S_NAMESPACE: default

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: azure-devops-assignment
    outputs:
      artifact_id: ${{ steps.upload_images_artifact.outputs.artifact_id || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build & push user-service
        id: build_user
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/user-service:${{ github.sha }}
          echo "Building ${IMAGE}"
          docker build -t $IMAGE ./user-service
          docker push $IMAGE
          echo "$IMAGE" > /tmp/image_user.txt
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT

      - name: Build & push order-service
        id: build_order
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/order-service:${{ github.sha }}
          echo "Building ${IMAGE}"
          docker build -t $IMAGE ./order-service
          docker push $IMAGE
          echo "$IMAGE" > /tmp/image_order.txt
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT

      - name: Build & push gateway
        id: build_gateway
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/gateway:${{ github.sha }}
          echo "Building ${IMAGE}"
          docker build -t $IMAGE ./gateway
          docker push $IMAGE
          echo "$IMAGE" > /tmp/image_gateway.txt
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT

      - name: Create images.json
        id: create_images_json
        run: |
          USER_IMG=$(cat /tmp/image_user.txt)
          ORDER_IMG=$(cat /tmp/image_order.txt)
          GATEWAY_IMG=$(cat /tmp/image_gateway.txt)
          jq -n --arg u "$USER_IMG" --arg o "$ORDER_IMG" --arg g "$GATEWAY_IMG" \
            '{user: $u, order: $o, gateway: $g}' > images.json
          echo "Created images.json:"
          cat images.json

      - name: Upload images artifact
        id: upload_images_artifact
        uses: actions/upload-artifact@v4
        with:
          name: images-json
          path: images.json

  # scan-images:
  #   needs: build-and-push
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Download images artifact
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: images-json
  #         path: ./artifacts

  #     - name: Show images.json
  #       run: cat ./artifacts/images.json

  #     - name: Trivy scan - user
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: $(jq -r '.user' ./artifacts/images.json)

  #     - name: Trivy scan - order
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: $(jq -r '.order' ./artifacts/images.json)

  #     - name: Trivy scan - gateway
  #       uses: aquasecurity/trivy-action@v1
  #       with:
  #         image-ref: $(jq -r '.gateway' ./artifacts/images.json)

  deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    environment: azure-devops-assignment
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download images artifact
        uses: actions/download-artifact@v4
        with:
          name: images-json
          path: ./artifacts

      - name: Read images into env
        id: read_images
        run: |
          USER_IMG=$(jq -r '.user' ./artifacts/images.json)
          ORDER_IMG=$(jq -r '.order' ./artifacts/images.json)
          GATEWAY_IMG=$(jq -r '.gateway' ./artifacts/images.json)
          echo "USER_IMG=${USER_IMG}" >> $GITHUB_OUTPUT
          echo "ORDER_IMG=${ORDER_IMG}" >> $GITHUB_OUTPUT
          echo "GATEWAY_IMG=${GATEWAY_IMG}" >> $GITHUB_OUTPUT

      - name: Debug print image values
        run: |
          echo "User image from artifact: ${{ steps.read_images.outputs.USER_IMG || '' }}"
          echo "Order image from artifact: ${{ steps.read_images.outputs.ORDER_IMG || '' }}"
          echo "Gateway image from artifact: ${{ steps.read_images.outputs.GATEWAY_IMG || '' }}"

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS credentials (kubectl context)
        uses: azure/aks-set-context@v3
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          cluster-name: ${{ secrets.AKS_NAME }}
          resource-group: ${{ secrets.AKS_RG }}

      - name: Confirm kubectl connectivity
        run: |
          kubectl get nodes -o wide
          kubectl -n "${{ env.K8S_NAMESPACE }}" get deploy || true

      - name: Apply k8s manifests (create/update resources)
        run: |
          kubectl apply -f k8s/ -n "${{ env.K8S_NAMESPACE }}" || kubectl apply -f k8s/

      - name: Wait for new resources to be accepted by API (short)
        run: sleep 5

      - name: Update images (read from artifact) and wait for rollout
        env:
          IMAGE_USER: ${{ steps.read_images.outputs.USER_IMG }}
          IMAGE_ORDER: ${{ steps.read_images.outputs.ORDER_IMG }}
          IMAGE_GATEWAY: ${{ steps.read_images.outputs.GATEWAY_IMG }}
          NAMESPACE: ${{ env.K8S_NAMESPACE }}
        run: |
          set -euo pipefail
          echo "IMAGE_USER=${IMAGE_USER}"
          # show current deployments
          kubectl -n "$NAMESPACE" get deploy -o wide || true

          if [ -n "${IMAGE_USER:-}" ]; then
            echo "Updating user-service -> ${IMAGE_USER}"
            kubectl -n "$NAMESPACE" set image deployment/user-service user="${IMAGE_USER}" || true
            kubectl -n "$NAMESPACE" rollout status deployment/user-service --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy user-service && kubectl -n "$NAMESPACE" get pods -l app=user-service -o wide && exit 1)
          else
            echo "IMAGE_USER empty — skipping user-service update"
          fi

          if [ -n "${IMAGE_ORDER:-}" ]; then
            echo "Updating order-service -> ${IMAGE_ORDER}"
            kubectl -n "$NAMESPACE" set image deployment/order-service order="${IMAGE_ORDER}" || true
            kubectl -n "$NAMESPACE" rollout status deployment/order-service --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy order-service && kubectl -n "$NAMESPACE" get pods -l app=order-service -o wide && exit 1)
          else
            echo "IMAGE_ORDER empty — skipping order-service update"
          fi

          if [ -n "${IMAGE_GATEWAY:-}" ]; then
            echo "Updating gateway -> ${IMAGE_GATEWAY}"
            kubectl -n "$NAMESPACE" set image deployment/gateway gateway="${IMAGE_GATEWAY}" || true
            kubectl -n "$NAMESPACE" rollout status deployment/gateway --timeout=180s || (kubectl -n "$NAMESPACE" describe deploy gateway && kubectl -n "$NAMESPACE" get pods -l app=gateway -o wide && exit 1)
          else
            echo "IMAGE_GATEWAY empty — skipping gateway update"
          fi

      - name: Post-deploy smoke test (gateway health)
        run: |
          LB_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || true)
          if [ -n "$LB_IP" ]; then
            echo "Gateway LB IP: $LB_IP"
            curl --fail --retry 5 --retry-delay 2 "http://$LB_IP/health"
          else
            echo "No external LB IP — testing from a pod"
            POD=$(kubectl -n "${{ env.K8S_NAMESPACE }}" get pods -l app=gateway -o jsonpath="{.items[0].metadata.name}")
            kubectl -n "${{ env.K8S_NAMESPACE }}" exec "$POD" -- curl --fail --retry 5 --retry-delay 2 http://localhost:3000/health
          fi
